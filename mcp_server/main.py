# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:19:38+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic
from fastapi import Header, Path, Query

from models import (
    AddOrUpdateIntegrationLinkModel,
    AddOrUpdateJiraIntegrationLinkModel,
    AddUserToGroupRequest,
    AuditLogType,
    CodeReferenceRequest,
    ConfigModelHaljson,
    ConfigSettingValuesModel,
    ConnectRequest,
    CreateConfigRequest,
    CreateEnvironmentModel,
    CreatePermissionGroupRequest,
    CreateProductRequest,
    CreateSegmentModel,
    CreateSettingInitialValues,
    CreateTagModel,
    DeleteIntegrationLinkModel,
    DeleteRepositoryReportsRequest,
    EnvironmentModelHaljson,
    IntegrationLinkDetailsModel,
    IntegrationLinkModel,
    IntegrationLinkType,
    InviteMembersRequest,
    JsonPatch,
    MeModel,
    PermissionGroupModelHaljson,
    ProductModelHaljson,
    SdkKeysModel,
    SegmentModelHaljson,
    SettingModelHaljson,
    SettingValueModelHaljson,
    TagModelHaljson,
    UpdateConfigRequest,
    UpdateEnvironmentModel,
    UpdatePermissionGroupRequest,
    UpdateProductRequest,
    UpdateSegmentModel,
    UpdateSettingValueModel,
    UpdateTagModel,
    V1ConfigsConfigIdDeletedSettingsGetResponse,
    V1ConfigsConfigIdSettingsGetResponse,
    V1OrganizationsGetResponse,
    V1OrganizationsOrganizationIdAuditlogsGetResponse,
    V1OrganizationsOrganizationIdMembersGetResponse,
    V1ProductsGetResponse,
    V1ProductsProductIdAuditlogsGetResponse,
    V1ProductsProductIdConfigsGetResponse,
    V1ProductsProductIdEnvironmentsGetResponse,
    V1ProductsProductIdMembersGetResponse,
    V1ProductsProductIdPermissionsGetResponse,
    V1ProductsProductIdSegmentsGetResponse,
    V1ProductsProductIdTagsGetResponse,
    V1TagsTagIdSettingsGetResponse,
)

app = MCPProxy(
    contact={
        'email': 'support@configcat.com',
        'name': 'ConfigCat',
        'url': 'https://configcat.com',
        'x-twitter': 'configcat',
    },
    description='**Base API URL**: https://api.configcat.com\n\nIf you prefer the swagger documentation, you can find it here: [Swagger UI](https://api.configcat.com/swagger).\n\nThe purpose of this API is to access the ConfigCat platform programmatically. \nYou can **Create**, **Read**, **Update** and **Delete** any entities like **Feature Flags, Configs, Environments** or **Products** within ConfigCat. \n\nThe API is based on HTTP REST, uses resource-oriented URLs, status codes and supports JSON \nand JSON+HAL format. Do not use this API for accessing and evaluating feature flag values. Use the [SDKs instead](https://configcat.com/docs/sdk-reference/overview).\n\n\n# OpenAPI Specification\n\nThe complete specification is publicly available here: [swagger.json](v1/swagger.json). \nYou can use it to generate client libraries in various languages with [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) or\n[Swagger Codegen](https://swagger.io/tools/swagger-codegen/) to interact with this API.\n\n# Authentication\nThis API uses the [Basic HTTP Authentication Scheme](https://en.wikipedia.org/wiki/Basic_access_authentication). \n\n<!-- ReDoc-Inject: <security-definitions> -->\n\n# Throttling and rate limits\nAll the rate limited API calls are returning information about the current rate limit period in the following HTTP headers:\n\n| Header | Description |\n| :- | :- |\n| X-Rate-Limit-Remaining | The maximum number of requests remaining in the current rate limit period. |\n| X-Rate-Limit-Reset     | The time\twhen the current rate limit period resets.\t\t\t\t\t\t  |\n\nWhen the rate limit is exceeded by a request, the API returns with a `HTTP 429 - Too many requests` status along with a `Retry-After` HTTP header.\n',
    termsOfService='https://configcat.com/termsofserviceagreement',
    title='ConfigCat Public Management API',
    version='v1',
    servers=[{'url': 'https://api.configcat.com'}],
)


@app.post(
    '/v1/code-references',
    tags=['configuration_management', 'config_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_v1_code_references(body: CodeReferenceRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/code-references/delete-reports',
    tags=['product_management', 'audit_log_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_v1_code_references_delete_reports(body: DeleteRepositoryReportsRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/configs/{configId}',
    description=""" This endpoint removes a Config identified by the `configId` parameter. """,
    tags=['configuration_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_config(config_id: UUID = Path(..., alias='configId')):
    """
    Delete Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configs/{configId}',
    description=""" This endpoint returns the metadata of a Config
identified by the `configId`. """,
    tags=['configuration_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_config(config_id: UUID = Path(..., alias='configId')):
    """
    Get Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/configs/{configId}',
    description=""" This endpoint updates a Config identified by the `configId` parameter. """,
    tags=['configuration_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_config(
    config_id: UUID = Path(..., alias='configId'), body: UpdateConfigRequest = ...
):
    """
    Update Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configs/{configId}/deleted-settings',
    description=""" This endpoint returns the list of Feature Flags and Settings that were deleted from the given Config. """,
    tags=['setting_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_deleted_settings(config_id: UUID = Path(..., alias='configId')):
    """
    List Deleted Settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configs/{configId}/environments/{environmentId}',
    description=""" This endpoint returns the SDK Key for your Config in a specified Environment. """,
    tags=['configuration_management', 'environment_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_sdk_keys(
    config_id: UUID = Path(..., alias='configId'),
    environment_id: UUID = Path(..., alias='environmentId'),
):
    """
    Get SDK Key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configs/{configId}/environments/{environmentId}/values',
    description=""" This endpoint returns the value of a specified Config's Feature Flags or Settings identified by the `configId` parameter
in a specified Environment identified by the `environmentId` parameter.

The most important attributes in the response are the `value`, `rolloutRules` and `percentageRules`.
The `value` represents what the clients will get when the evaluation requests of our SDKs 
are not matching to any of the defined Targeting or Percentage Rules, or when there are no additional rules to evaluate.

The `rolloutRules` and `percentageRules` attributes are representing the current 
Targeting and Percentage Rules configuration of the actual Feature Flag or Setting 
in an **ordered** collection, which means the order of the returned rules is matching to the
evaluation order. You can read more about these rules [here](https://configcat.com/docs/advanced/targeting/). """,
    tags=['configuration_management', 'environment_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_setting_values(
    config_id: UUID = Path(..., alias='configId'),
    environment_id: UUID = Path(..., alias='environmentId'),
):
    """
    Get values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configs/{configId}/settings',
    description=""" This endpoint returns the list of the Feature Flags and Settings defined in a 
specified Config, identified by the `configId` parameter. """,
    tags=['config_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_settings(config_id: UUID = Path(..., alias='configId')):
    """
    List Flags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/configs/{configId}/settings',
    description=""" This endpoint creates a new Feature Flag or Setting in a specified Config
identified by the `configId` parameter.

**Important:** The `key` attribute must be unique within the given Config. """,
    tags=['configuration_management', 'setting_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_setting(
    config_id: UUID = Path(..., alias='configId'),
    body: CreateSettingInitialValues = ...,
):
    """
    Create Flag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/environments/{environmentId}',
    description=""" This endpoint removes an Environment identified by the `environmentId` parameter. """,
    tags=['environment_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_environment(environment_id: UUID = Path(..., alias='environmentId')):
    """
    Delete Environment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/environments/{environmentId}',
    description=""" This endpoint returns the metadata of an Environment 
identified by the `environmentId`. """,
    tags=['environment_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_environment(environment_id: UUID = Path(..., alias='environmentId')):
    """
    Get Environment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/environments/{environmentId}',
    description=""" This endpoint updates an Environment identified by the `environmentId` parameter. """,
    tags=['environment_management', 'configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_environment(
    environment_id: UUID = Path(..., alias='environmentId'),
    body: UpdateEnvironmentModel = ...,
):
    """
    Update Environment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/environments/{environmentId}/settings/{settingId}/integrationLinks/{integrationLinkType}/{key}',
    tags=['integration_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_integration_link(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
    integration_link_type: IntegrationLinkType = Path(..., alias='integrationLinkType'),
    key: str = ...,
):
    """
    Delete Integration link
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/environments/{environmentId}/settings/{settingId}/integrationLinks/{integrationLinkType}/{key}',
    tags=['integration_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_or_update_integration_link(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
    integration_link_type: IntegrationLinkType = Path(..., alias='integrationLinkType'),
    key: str = ...,
    body: AddOrUpdateIntegrationLinkModel = None,
):
    """
    Add or update Integration link
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/environments/{environmentId}/settings/{settingId}/value',
    description=""" This endpoint returns the value of a Feature Flag or Setting 
in a specified Environment identified by the `environmentId` parameter.

The most important attributes in the response are the `value`, `rolloutRules` and `percentageRules`.
The `value` represents what the clients will get when the evaluation requests of our SDKs 
are not matching to any of the defined Targeting or Percentage Rules, or when there are no additional rules to evaluate.

The `rolloutRules` and `percentageRules` attributes are representing the current 
Targeting and Percentage Rules configuration of the actual Feature Flag or Setting 
in an **ordered** collection, which means the order of the returned rules is matching to the
evaluation order. You can read more about these rules [here](https://configcat.com/docs/advanced/targeting/). """,
    tags=['setting_management', 'configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_setting_value(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
):
    """
    Get value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/environments/{environmentId}/settings/{settingId}/value',
    description=""" This endpoint updates the value of a Feature Flag or Setting 
with a collection of [JSON Patch](http://jsonpatch.com) operations in a specified Environment.

Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.

The advantage of using JSON Patch is that you can describe individual update operations on a resource
without touching attributes that you don't want to change. It supports collection reordering, so it also 
can be used for reordering the targeting rules of a Feature Flag or Setting.

For example: We have the following resource.
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": false
}
```
If we send an update request body as below:
```
[
	{
		"op": "replace",
		"path": "/value",
		"value": true
	}
]
```
Only the default value is going to be set to `true` and all the Percentage Rules are remaining unchanged.
So we get a response like this:
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": true
}
```

The `rolloutRules` property describes two types of rules:

- **Targeting rules**: When you want to add or update a targenting rule, the `comparator`, `comparisonAttribute`, and `comparisonValue` members are required.
- **Segment rules**: When you want to add add or update a segment rule, the `segmentId` which identifies the desired segment and the `segmentComparator` members are required. """,
    tags=['setting_management', 'configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_setting_value(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
    reason: Optional[str] = None,
    body: JsonPatch = ...,
):
    """
    Update value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/environments/{environmentId}/settings/{settingId}/value',
    description=""" This endpoint replaces the whole value of a Feature Flag or Setting in a specified Environment.

Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.

**Important:** As this endpoint is doing a complete replace, it's important to set every other attribute that you don't 
want to change in its original state. Not listing one means that it will reset.

For example: We have the following resource.
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": false
}
```
If we send a replace request body as below:
```
{
	"value": true
}
```
Then besides that the default value is set to `true`, all the Percentage Rules are deleted. 
So we get a response like this:
```
{
	"rolloutPercentageItems": [],
	"rolloutRules": [],
	"value": true
}
```

The `rolloutRules` property describes two types of rules:

- **Targeting rules**: When you want to add or update a targenting rule, the `comparator`, `comparisonAttribute`, and `comparisonValue` members are required.
- **Segment rules**: When you want to add add or update a segment rule, the `segmentId` which identifies the desired segment and the `segmentComparator` members are required. """,
    tags=['setting_management', 'configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def replace_setting_value(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
    reason: Optional[str] = None,
    body: UpdateSettingValueModel = ...,
):
    """
    Replace value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/integrationLink/{integrationLinkType}/{key}/details',
    tags=['integration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_integration_link_details(
    integration_link_type: IntegrationLinkType = Path(..., alias='integrationLinkType'),
    key: str = ...,
):
    """
    Get Integration link
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/jira/Connect',
    tags=['configuration_management', 'config_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_v1_jira__connect(body: ConnectRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/jira/environments/{environmentId}/settings/{settingId}/integrationLinks/{key}',
    tags=['integration_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def jira_add_or_update_integration_link(
    environment_id: UUID = Path(..., alias='environmentId'),
    setting_id: int_aliased = Path(..., alias='settingId'),
    key: str = ...,
    body: AddOrUpdateJiraIntegrationLinkModel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/me',
    tags=['user_management', 'organization_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_me():
    """
    Get authenticated user details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/organizations',
    description=""" This endpoint returns the list of the Organizations that belongs to the user. """,
    tags=['organization_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_organizations():
    """
    List Organizations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/organizations/{organizationId}/auditlogs',
    description=""" This endpoint returns the list of Audit log items for a given Organization 
and the result can be optionally filtered by Product and/or Config and/or Environment. """,
    tags=['organization_management', 'audit_log_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_organization_auditlogs(
    organization_id: UUID = Path(..., alias='organizationId'),
    product_id: Optional[UUID] = Query(None, alias='productId'),
    config_id: Optional[UUID] = Query(None, alias='configId'),
    environment_id: Optional[UUID] = Query(None, alias='environmentId'),
    audit_log_type: Optional[AuditLogType] = Query(None, alias='auditLogType'),
    from_utc_date_time: Optional[datetime] = Query(None, alias='fromUtcDateTime'),
    to_utc_date_time: Optional[datetime] = Query(None, alias='toUtcDateTime'),
):
    """
    List Audit log items for Organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/organizations/{organizationId}/members',
    description=""" This endpoint returns the list of Members that belongs 
to the given Organization, identified by the `organizationId` parameter. """,
    tags=['organization_management', 'user_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_organization_members(organization_id: UUID = Path(..., alias='organizationId')):
    """
    List Organization Members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/organizations/{organizationId}/members/{userId}',
    description=""" This endpoint removes a Member identified by the `userId` from the 
given Organization identified by the `organizationId` parameter. """,
    tags=['organization_management', 'user_management', 'user_membership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_organization_member(
    organization_id: UUID = Path(..., alias='organizationId'),
    user_id: str = Path(..., alias='userId'),
):
    """
    Delete Member from Organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/organizations/{organizationId}/members/{userId}',
    description=""" This endpoint adds a Member identified by the `userId` to one or more Permission Groups. 
This endpoint can also be used to move a Member between Permission Groups within a Product.
Only a single Permission Group can be set per Product. """,
    tags=['organization_management', 'user_management', 'user_membership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_member_to_group(
    organization_id: UUID = Path(..., alias='organizationId'),
    user_id: str = Path(..., alias='userId'),
    body: AddUserToGroupRequest = ...,
):
    """
    Update Member Permissions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/organizations/{organizationId}/products',
    description=""" This endpoint creates a new Product in a specified Organization 
identified by the `organizationId` parameter, which can be obtained from the [List Organizations](#operation/get-organizations) endpoint. """,
    tags=['product_management', 'organization_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_product(
    organization_id: UUID = Path(..., alias='organizationId'),
    body: CreateProductRequest = ...,
):
    """
    Create Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/permissions/{permissionGroupId}',
    description=""" This endpoint removes a Permission Group identified by the `permissionGroupId` parameter. """,
    tags=['permission_group_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_permission_group(
    permission_group_id: int_aliased = Path(..., alias='permissionGroupId')
):
    """
    Delete Permission Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/permissions/{permissionGroupId}',
    description=""" This endpoint returns the metadata of a Permission Group 
identified by the `permissionGroupId`. """,
    tags=['permission_group_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_permission_group(
    permission_group_id: int_aliased = Path(..., alias='permissionGroupId')
):
    """
    Get Permission Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/permissions/{permissionGroupId}',
    description=""" This endpoint updates a Permission Group identified by the `permissionGroupId` parameter. """,
    tags=['permission_group_management', 'user_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_permission_group(
    permission_group_id: int_aliased = Path(..., alias='permissionGroupId'),
    body: UpdatePermissionGroupRequest = ...,
):
    """
    Update Permission Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products',
    description=""" This endpoint returns the list of the Products that belongs to the user. """,
    tags=['product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_products():
    """
    List Products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/products/{productId}',
    description=""" This endpoint removes a Product identified by the `productId` parameter. """,
    tags=['product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_product(product_id: UUID = Path(..., alias='productId')):
    """
    Delete Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}',
    description=""" This endpoint returns the metadata of a Product 
identified by the `productId`. """,
    tags=['product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_product(product_id: UUID = Path(..., alias='productId')):
    """
    Get Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/products/{productId}',
    description=""" This endpoint updates a Product identified by the `productId` parameter. """,
    tags=['product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_product(
    product_id: UUID = Path(..., alias='productId'), body: UpdateProductRequest = ...
):
    """
    Update Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/auditlogs',
    description=""" This endpoint returns the list of Audit log items for a given Product 
and the result can be optionally filtered by Config and/or Environment. """,
    tags=['audit_log_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_auditlogs(
    product_id: UUID = Path(..., alias='productId'),
    config_id: Optional[UUID] = Query(None, alias='configId'),
    environment_id: Optional[UUID] = Query(None, alias='environmentId'),
    audit_log_type: Optional[AuditLogType] = Query(None, alias='auditLogType'),
    from_utc_date_time: Optional[datetime] = Query(None, alias='fromUtcDateTime'),
    to_utc_date_time: Optional[datetime] = Query(None, alias='toUtcDateTime'),
):
    """
    List Audit log items for Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/configs',
    description=""" This endpoint returns the list of the Configs that belongs to the given Product identified by the
`productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['config_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_configs(product_id: UUID = Path(..., alias='productId')):
    """
    List Configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/configs',
    description=""" This endpoint creates a new Config in a specified Product 
identified by the `productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['configuration_management', 'config_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_config(
    product_id: UUID = Path(..., alias='productId'), body: CreateConfigRequest = ...
):
    """
    Create Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/environments',
    description=""" This endpoint returns the list of the Environments that belongs to the given Product identified by the
`productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['environment_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_environments(product_id: UUID = Path(..., alias='productId')):
    """
    List Environments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/environments',
    description=""" This endpoint creates a new Environment in a specified Product 
identified by the `productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['environment_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_environment(
    product_id: UUID = Path(..., alias='productId'), body: CreateEnvironmentModel = ...
):
    """
    Create Environment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/members',
    description=""" This endpoint returns the list of Members that belongs 
to the given Product, identified by the `productId` parameter. """,
    tags=['product_management', 'user_membership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_product_members(product_id: UUID = Path(..., alias='productId')):
    """
    List Product Members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/members/invite',
    description=""" This endpoint invites a Member into the given Product identified by the `productId` parameter. """,
    tags=['user_membership_management', 'organization_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def invite_member(
    product_id: UUID = Path(..., alias='productId'), body: InviteMembersRequest = ...
):
    """
    Invite Member
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/products/{productId}/members/{userId}',
    description=""" This endpoint removes a Member identified by the `userId` from the 
given Product identified by the `productId` parameter. """,
    tags=[
        'organization_management',
        'user_management',
        'user_membership_management',
        'product_management',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_product_member(
    product_id: UUID = Path(..., alias='productId'),
    user_id: str = Path(..., alias='userId'),
):
    """
    Delete Member from Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/permissions',
    description=""" This endpoint returns the list of the Permission Groups that belongs to the given Product identified by the
`productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['permission_group_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_permission_groups(product_id: UUID = Path(..., alias='productId')):
    """
    List Permission Groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/permissions',
    description=""" This endpoint creates a new Permission Group in a specified Product 
identified by the `productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['permission_group_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_permission_group(
    product_id: UUID = Path(..., alias='productId'),
    body: CreatePermissionGroupRequest = ...,
):
    """
    Create Permission Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/segments',
    description=""" This endpoint returns the list of the Segments that belongs to the given Product identified by the
`productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['segment_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_segments(product_id: UUID = Path(..., alias='productId')):
    """
    List Segments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/segments',
    description=""" This endpoint creates a new Segment in a specified Product 
identified by the `productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['segment_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_segment(
    product_id: UUID = Path(..., alias='productId'), body: CreateSegmentModel = ...
):
    """
    Create Segment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/products/{productId}/tags',
    description=""" This endpoint returns the list of the Tags in a 
specified Product, identified by the `productId` parameter. """,
    tags=['tag_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_tags(product_id: UUID = Path(..., alias='productId')):
    """
    List Tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/products/{productId}/tags',
    description=""" This endpoint creates a new Tag in a specified Product 
identified by the `productId` parameter, which can be obtained from the [List Products](#operation/get-products) endpoint. """,
    tags=['tag_management', 'product_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_tag(
    product_id: UUID = Path(..., alias='productId'), body: CreateTagModel = ...
):
    """
    Create Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/segments/{segmentId}',
    description=""" This endpoint removes a Segment identified by the `segmentId` parameter. """,
    tags=['segment_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_segment(segment_id: UUID = Path(..., alias='segmentId')):
    """
    Delete Segment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/segments/{segmentId}',
    description=""" This endpoint returns the metadata of a Segment
identified by the `segmentId`. """,
    tags=['segment_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_segment(segment_id: UUID = Path(..., alias='segmentId')):
    """
    Get Segment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/segments/{segmentId}',
    description=""" This endpoint updates a Segment identified by the `segmentId` parameter. """,
    tags=['segment_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_segment(
    segment_id: UUID = Path(..., alias='segmentId'), body: UpdateSegmentModel = ...
):
    """
    Update Segment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/settings/{settingId}',
    description=""" This endpoint removes a Feature Flag or Setting from a specified Config, 
identified by the `configId` parameter. """,
    tags=['setting_management', 'configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_setting(setting_id: int_aliased = Path(..., alias='settingId')):
    """
    Delete Flag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/settings/{settingId}',
    description=""" This endpoint returns the metadata attributes of a Feature Flag or Setting 
identified by the `settingId` parameter. """,
    tags=['setting_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_setting(setting_id: int_aliased = Path(..., alias='settingId')):
    """
    Get Flag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/settings/{settingId}',
    description=""" This endpoint updates the metadata of a Feature Flag or Setting 
with a collection of [JSON Patch](http://jsonpatch.com) operations in a specified Config.

Only the `name`, `hint` and `tags` attributes are modifiable by this endpoint.
The `tags` attribute is a simple collection of the [tag IDs](#operation/get-tags) attached to the given setting.

The advantage of using JSON Patch is that you can describe individual update operations on a resource
without touching attributes that you don't want to change.

For example: We have the following resource.
```
{
	"settingId": 5345,
	"key": "myGrandFeature",
	"name": "Tihs is a naem with soem typos.",
	"hint": "This flag controls my grandioso feature.",
	"settingType": "boolean",
	"tags": [
		{
			"tagId": 0,
			"name": "sample tag",
			"color": "whale"
		}
	]
}
```
If we send an update request body as below (it changes the name and adds the already existing tag with the id 2):
```
[
	{
		"op": "replace",
		"path": "/name",
		"value": "This is the name without typos."
	},
	{
		"op": "add",
		"path": "/tags/-",
		"value": 2
	}
]
```
Only the `name` and `tags` are going to be updated and all the other attributes are remaining unchanged.
So we get a response like this:
```
{
	"settingId": 5345,
	"key": "myGrandFeature",
	"name": "This is the name without typos.",
	"hint": "This flag controls my grandioso feature.",
	"settingType": "boolean",
	"tags": [
		{
			"tagId": 0,
			"name": "sample tag",
			"color": "whale"
		},
		{
			"tagId": 2,
			"name": "another tag",
			"color": "koala"
		}
	]
}
``` """,
    tags=['setting_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_setting(
    setting_id: int_aliased = Path(..., alias='settingId'), body: JsonPatch = ...
):
    """
    Update Flag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/settings/{settingKeyOrId}/value',
    description=""" This endpoint returns the value of a Feature Flag or Setting 
in a specified Environment identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.

The most important attributes in the response are the `value`, `rolloutRules` and `percentageRules`.
The `value` represents what the clients will get when the evaluation requests of our SDKs 
are not matching to any of the defined Targeting or Percentage Rules, or when there are no additional rules to evaluate.

The `rolloutRules` and `percentageRules` attributes are representing the current 
Targeting and Percentage Rules configuration of the actual Feature Flag or Setting 
in an **ordered** collection, which means the order of the returned rules is matching to the
evaluation order. You can read more about these rules [here](https://configcat.com/docs/advanced/targeting/). """,
    tags=['configuration_management', 'setting_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_setting_value_by_sdkkey(
    setting_key_or_id: str = Path(..., alias='settingKeyOrId'),
    x__c_o_n_f_i_g_c_a_t__s_d_k_k_e_y: Optional[str] = Header(
        None, alias='X-CONFIGCAT-SDKKEY'
    ),
):
    """
    Get value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/settings/{settingKeyOrId}/value',
    description=""" This endpoint updates the value of a Feature Flag or Setting 
with a collection of [JSON Patch](http://jsonpatch.com) operations in a specified Environment
identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.

Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.

The advantage of using JSON Patch is that you can describe individual update operations on a resource
without touching attributes that you don't want to change. It supports collection reordering, so it also 
can be used for reordering the targeting rules of a Feature Flag or Setting.

For example: We have the following resource.
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": false
}
```
If we send an update request body as below:
```
[
	{
		"op": "replace",
		"path": "/value",
		"value": true
	}
]
```
Only the default served value is going to be set to `true` and all the Percentage Rules are remaining unchanged.
So we get a response like this:
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": true
}
``` """,
    tags=['setting_management', 'configuration_management', 'config_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_setting_value_by_sdkkey(
    setting_key_or_id: str = Path(..., alias='settingKeyOrId'),
    reason: Optional[str] = None,
    x__c_o_n_f_i_g_c_a_t__s_d_k_k_e_y: Optional[str] = Header(
        None, alias='X-CONFIGCAT-SDKKEY'
    ),
    body: JsonPatch = ...,
):
    """
    Update value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/settings/{settingKeyOrId}/value',
    description=""" This endpoint replaces the value of a Feature Flag or Setting 
in a specified Environment identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.

Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.

**Important:** As this endpoint is doing a complete replace, it's important to set every other attribute that you don't 
want to change to its original state. Not listing one means that it will reset.

For example: We have the following resource.
```
{
	"rolloutPercentageItems": [
		{
			"percentage": 30,
			"value": true
		},
		{
			"percentage": 70,
			"value": false
		}
	],
	"rolloutRules": [],
	"value": false
}
```
If we send a replace request body as below:
```
{
	"value": true
}
```
Then besides that the default served value is set to `true`, all the Percentage Rules are deleted. 
So we get a response like this:
```
{
	"rolloutPercentageItems": [],
	"rolloutRules": [],
	"value": true
}
``` """,
    tags=['configuration_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def replace_setting_value_by_sdkkey(
    setting_key_or_id: str = Path(..., alias='settingKeyOrId'),
    reason: Optional[str] = None,
    x__c_o_n_f_i_g_c_a_t__s_d_k_k_e_y: Optional[str] = Header(
        None, alias='X-CONFIGCAT-SDKKEY'
    ),
    body: UpdateSettingValueModel = ...,
):
    """
    Replace value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/tags/{tagId}',
    description=""" This endpoint deletes a Tag identified by the `tagId` parameter. To remove a Tag from a Feature Flag or Setting use the [Update Flag](#operation/update-setting) endpoint. """,
    tags=['tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_tag(tag_id: int_aliased = Path(..., alias='tagId')):
    """
    Delete Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags/{tagId}',
    description=""" This endpoint returns the metadata of a Tag 
identified by the `tagId`. """,
    tags=['tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_tag(tag_id: int_aliased = Path(..., alias='tagId')):
    """
    Get Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/tags/{tagId}',
    description=""" This endpoint updates a Tag identified by the `tagId` parameter. """,
    tags=['tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_tag(
    tag_id: int_aliased = Path(..., alias='tagId'), body: UpdateTagModel = ...
):
    """
    Update Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags/{tagId}/settings',
    description=""" This endpoint returns the list of the Settings that 
has the specified Tag, identified by the `tagId` parameter. """,
    tags=['tag_management', 'setting_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_settings_by_tag(tag_id: int_aliased = Path(..., alias='tagId')):
    """
    List Settings by Tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
